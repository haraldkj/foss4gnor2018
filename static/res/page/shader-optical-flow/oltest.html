<!DOCTYPE html>
<html>
  <head>
    <title>Layer Clipping with WebGL</title>
    <link rel="stylesheet" href="./lib/ol/ol.css" type="text/css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
        <script src="./lib/ol/ol-debug.js"></script>
  </head>
  <body>
    <div id="map" class="map"></div>
    <div id="no-webgl" class="alert alert-danger" style="display: none">
      This example requires a browser that supports <a href="http://get.webgl.org/">WebGL</a>.
    </div>
    <script>
      if (!ol.has.WEBGL) {
        var info = document.getElementById('no-webgl');
        /**
         * display error message
         */
        info.style.display = '';
      } else {

        var osm = new ol.layer.Tile({
          source: new ol.source.OSM()
        });

        var map = new ol.Map({
          layers: [osm],
          renderer: /** @type {ol.renderer.Type} */ ('webgl'),
          target: 'map',
          controls: ol.control.defaults({
            attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
              collapsible: false
            })
          }),
          view: new ol.View({
            center: [0, 0],
            zoom: 2
          })
        });
//https://github.com/gracefung/webgl-codes/blob/master/lesson05/index5-2.html
//https://webglfundamentals.org/webgl/lessons/webgl-2-textures.html
        var fragmentShaderSource =
          `
          #ifdef GL_ES
          precision mediump float;
          precision mediump int;
          #endif

          uniform vec2 u_mouse;
          uniform float u_time;
          uniform vec2 u_resolution;
          uniform sampler2D	tex_z1; // current  image
          uniform sampler2D	tex_z2; // next image
          uniform sampler2D tex_flow_fwd; // flow texture
          uniform sampler2D tex_flow_rev; // flow texture

          void main() {
            float time = abs(sin(u_time)); // 0 - 1
            vec2 xy = gl_FragCoord.xy / vec2(500, 500);
            gl_FragColor = vec4(1.0,1.0,1.0,time);

            gl_FragColor = vec4(texture2D(tex_flow_fwd,xy).rgb,0.7);
            /*
            vec2 fwd = ((texture2D(tex_flow_fwd, xy).rg) * 30.0 - 15.0) / vec2(500, 500).xy;
            vec2 rev = ((texture2D(tex_flow_rev, xy).rg) * 30.0 - 15.0) / vec2(500, 500).xy;
            float interpol = time;

            vec3 zforward = texture2D(tex_z1, xy - fwd * interpol).rgb / 2.;
            vec3 zbackward = texture2D(tex_z2, xy + rev * interpol).rgb / 2.;
            vec3 blend = mix(zforward, zbackward, interpol) * 2.;
            gl_FragColor = vec4(blend, 0.5);
            */
          }
          `;

        var vertexShaderSource = `
          attribute vec4 a_position;
            void main(){
              gl_Position = a_position;
          }`;

          var texImages = null;
        osm.on('precompose', function(event) {
          context = event.glContext;
          gl = context.getGL();
          gl.disable(gl.STENCIL_TEST);
        });

        var timestamp = 0;
        var gl = null;
        var program = null;
        osm.on('postcompose', function(event) {
          var context = event.glContext;

          gl = context.getGL();
          // Clear the canvas
          program = gl.createProgram();

          var vertexShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertexShader, vertexShaderSource);
          gl.compileShader(vertexShader);
          gl.attachShader(program, vertexShader);

          var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragmentShader, fragmentShaderSource);
          gl.compileShader(fragmentShader);
          gl.attachShader(program, fragmentShader);

          gl.linkProgram(program);
          context.useProgram(program);
          if(texImages) {
            render(texImages);
          }
          var positionLocation = gl.getAttribLocation(program, 'a_position');

          //gl.enable(gl.STENCIL_TEST);
          //gl.colorMask(true, true, true, true);
          //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          //gl.stencilFunc(gl.ALWAYS, 1, 0xff);

          var buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // first band
            -1.0, -1.0, 1.0, -1.0, 1.0, 1.0,
            -1.0, 1.0, -1.0, -1.0, 1.0, 1.0

          ]), gl.STATIC_DRAW);

          var time = gl.getUniformLocation(program, "u_time");

          gl.uniform1f(time, timestamp);
          //gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
        });

        var start = null;
        function step(t) {
          timestamp = t / 1000;
          if (!start) start = t;
          var progress = t - start;
          //map.render();

          //window.requestAnimationFrame(step);
        }
      }

      //initTextures();

      function render(images) {

        // create 2 textures
        var textures = [];
        for (var ii = 0; ii < 4; ++ii) {
          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);

          // Set the parameters so we can render any size image.
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

          // Upload the image into the texture.
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[ii]);

          // add the texture to the array of textures.

          textures.push(texture);
        }

        // lookup the sampler locations.
        program.tex_flow_fwd =gl.getUniformLocation(program,"tex_flow_fwd");
        program.tex_flow_rev =gl.getUniformLocation(program,"tex_flow_rev");
        program.tex_z1 =gl.getUniformLocation(program,"tex_z1");
        program.tex_z2 =gl.getUniformLocation(program,"tex_z2");
        //var u_image0Location = gl.getUniformLocation(program, "u_image0");
        //var u_image1Location = gl.getUniformLocation(program, "u_image1");

        // set which texture units to render with.
        gl.uniform1i(program.tex_flow_fwd, 0);  // texture unit 0
        gl.uniform1i(program.tex_flow_rev, 7);
        gl.uniform1i(program.tex_z1, 8);
        gl.uniform1i(program.tex_z2, 9);
        //gl.uniform1i(u_image1Location, 1);  // texture unit 1
        // Set each texture unit to use a particular texture.
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textures[0]);

      };

      loadImages([
        './data/displacement/fwd_uv.png',
        './data/displacement/rev_uv.png',
        './data/displacement/frame0.png',
        './data/displacement/frame15.png'
      ], setImages);

      function setImages(images) {
        texImages = images;
      }

      function loadImages(urls, callback) {
        var images = [];
        var imagesToLoad = urls.length;

        // Called each time an image finished loading.
        var onImageLoad = function() {
          --imagesToLoad;
          // If all the images are loaded call the callback.
          if (imagesToLoad == 0) {
            callback(images);
          }
        };

        for (var ii = 0; ii < imagesToLoad; ++ii) {
          var image = loadImage(urls[ii], onImageLoad);
          images.push(image);
        }
      }

      function loadImage(url, callback) {
        var image = new Image();
        image.src = url;
        image.onload = callback;
        return image;
      }

    </script>
  </body>
</html>
