<!DOCTYPE html>
<html>
  <head>
    <title>Layer Clipping with WebGL</title>
    <link rel="stylesheet" href="./lib/ol/ol.css" type="text/css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
        <script src="./lib/ol/ol-debug.js"></script>
        <script src="./lib/webgl-utils.js"></script>
  </head>
  <body>
    <!-- vertex shader -->
    <script id="2d-vertex-shader" type="x-shader/x-vertex">
    attribute vec4 a_position;
      void main(){
        gl_Position = a_position;
    }
    </script>
    <!-- fragment shader -->
    <script id="2d-fragment-shader" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision mediump float;
      precision mediump int;
      #endif

      uniform vec2 u_mouse;
      uniform float u_time;
      uniform vec2 u_resolution;
      uniform sampler2D	tex_z1; // current  image
      uniform sampler2D	tex_z2; // next image
      uniform sampler2D tex_flow_fwd; // flow texture
      uniform sampler2D tex_flow_rev; // flow texture

      void main() {
        float time = abs(sin(u_time)); // 0 - 1
        vec2 xy = gl_FragCoord.xy / u_resolution.xy;
        vec2 fwd = ((texture2D(tex_flow_fwd, xy).rg) * 30.0 - 15.0) / u_resolution.xy;
        vec2 rev = ((texture2D(tex_flow_rev, xy).rg) * 30.0 - 15.0) / u_resolution.xy;
        float interpol = time;

        vec3 zforward = texture2D(tex_z1, xy - fwd * interpol).rgb / 2.;
        vec3 zbackward = texture2D(tex_z2, xy + rev * interpol).rgb / 2.;
        vec3 blend = mix(zforward, zbackward, interpol) * 2.;
        gl_FragColor = vec4(blend, 1.);
      }
    </script>
    <div id="map" class="map"></div>
    <div id="no-webgl" class="alert alert-danger" style="display: none">
      This example requires a browser that supports <a href="http://get.webgl.org/">WebGL</a>.
    </div>
    <script>
      if (!ol.has.WEBGL) {
        var info = document.getElementById('no-webgl');
        /**
         * display error message
         */
        info.style.display = '';
      } else {

        var osm = new ol.layer.Tile({
          source: new ol.source.OSM()
        });

        var map = new ol.Map({
          layers: [osm],
          renderer: /** @type {ol.renderer.Type} */ ('webgl'),
          target: 'map',
          controls: ol.control.defaults({
            attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
              collapsible: false
            })
          }),
          view: new ol.View({
            center: [0, 0],
            zoom: 2
          })
        });

        var canv = document.createElement('canvas');
        canv.id = 'glcanvas';
        canv.style.display = 'block';
        canv.style.position = 'absolute';
        canv.style.top = '0px';
        canv.style.left = '0px';
        canv.style.width = '484px';
        canv.style.height = '738px';

        //document.body.appendChild(canv); // adds the canvas to the body element
        map.getViewport().appendChild(canv); // adds the canvas to #someBox

        //https://github.com/gracefung/webgl-codes/blob/master/lesson05/index5-2.html
        //https://webglfundamentals.org/webgl/lessons/webgl-2-textures.html
        var texImages = null;
      }

      //initTextures();

      var gl, program;
      function render(timestamp) {

        // Get A WebGL context
        var canvas = document.getElementById("glcanvas");
        gl = canvas.getContext("webgl");
        if (!gl) {
          return;
        }

        // setup GLSL program
        program = webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);
        gl.useProgram(program);

        // look up where the vertex data needs to go.
        var positionLocation = gl.getAttribLocation(program, "a_position");
        var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

        // Create a buffer to put three 2d clip space points in
        var positionBuffer = gl.createBuffer();

        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // Set a rectangle the same size as the image.
        setRectangle(gl, 0, 0, texImages[0].width, texImages[0].height);

        // provide texture coordinates for the rectangle.
        var texcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0.0,  0.0,
            1.0,  0.0,
            0.0,  1.0,
            0.0,  1.0,
            1.0,  0.0,
            1.0,  1.0,
        ]), gl.STATIC_DRAW);

        // create 2 textures
        var textures = [];
        for (var ii = 0; ii < 4; ++ii) {
          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          // Set the parameters so we can render any size image.
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

          // Upload the image into the texture.
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texImages[ii]);

          // add the texture to the array of textures.

          textures.push(texture);
        }

        // lookup uniforms
        var resolutionLocation = gl.getUniformLocation(program, "u_resolution");

        // lookup the sampler locations.
        var u_image0Location = gl.getUniformLocation(program, "u_image0");
        var u_image1Location = gl.getUniformLocation(program, "u_image1");

        webglUtils.resizeCanvasToDisplaySize(gl.canvas);

        gl.viewport(-484, -738,968, 1476);

        // Clear the canvas
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Tell it to use our program (pair of shaders)
        gl.useProgram(program);

        // Turn on the position attribute
        gl.enableVertexAttribArray(positionLocation);

        // Bind the position buffer.
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var size = 2;          // 2 components per iteration
        var type = gl.FLOAT;   // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0;        // start at the beginning of the buffer
        gl.vertexAttribPointer(
            positionLocation, size, type, normalize, stride, offset)

        // set the resolution
        gl.uniform2f(resolutionLocation, 484, 738);

        // lookup the sampler locations.

        var tex_flow_fwd =gl.getUniformLocation(program,"tex_flow_fwd");
        var tex_flow_rev =gl.getUniformLocation(program,"tex_flow_rev");
        var tex_z1 =gl.getUniformLocation(program,"tex_z1");
        var tex_z2 =gl.getUniformLocation(program,"tex_z2");

        // set which texture units to render with.
        gl.uniform1i(tex_flow_fwd, 0);  // texture unit 0
        gl.uniform1i(tex_flow_rev, 1);
        gl.uniform1i(tex_z1, 2);
        gl.uniform1i(tex_z2, 3);
        //gl.uniform1i(u_image1Location, 1);  // texture unit 1
        // Set each texture unit to use a particular texture.
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textures[0]);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, textures[1]);
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, textures[2]);
        gl.activeTexture(gl.TEXTURE3);
        gl.bindTexture(gl.TEXTURE_2D, textures[3]);

        // Draw the rectangle.
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      };

      function animate(timestamp) {
        var time = gl.getUniformLocation(program, "u_time");

        gl.uniform1f(time, timestamp);
        gl.drawArrays(gl.TRIANGLES, 0, 6)
      }

      loadImages([
        './data/displacement/fwd_uv.png',
        './data/displacement/rev_uv.png',
        './data/displacement/frame0.png',
        './data/displacement/frame15.png'
      ], setImages);

      function setImages(images) {
        texImages = images;
        render();
        step(0);
      }

      function loadImages(urls, callback) {
        var images = [];
        var imagesToLoad = urls.length;

        // Called each time an image finished loading.
        var onImageLoad = function() {
          --imagesToLoad;
          // If all the images are loaded call the callback.
          if (imagesToLoad == 0) {
            callback(images);
          }
        };

        for (var ii = 0; ii < imagesToLoad; ++ii) {
          var image = loadImage(urls[ii], onImageLoad);
          images.push(image);
        }
      }

      function loadImage(url, callback) {
        var image = new Image();
        image.src = url;
        image.onload = callback;
        return image;
      }

      function setRectangle(gl, x, y, width, height) {
        var x1 = x;
        var x2 = x + width;
        var y1 = y;
        var y2 = y + height;
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
           x1, y1,
           x2, y1,
           x1, y2,
           x1, y2,
           x2, y1,
           x2, y2,
        ]), gl.STATIC_DRAW);
      }

      var start = null;
      function step(t) {
        var timestamp = t / 1000;
        if (!start) start = t;
        var progress = t - start;
        animate(timestamp);
        //map.render();

        window.requestAnimationFrame(step);
      }

    </script>
  </body>
</html>
